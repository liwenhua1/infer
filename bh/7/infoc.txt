{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 98];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 98];
      NULLIFY(&this); [line 98];
      EXIT_SCOPE(n$0,n$1,this); [line 98];
      
    #n5:
      APPLY_ABSTRACTION; [line 98];
      
    #n2:
      
    
    { proc_name= Cast$Sub2.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub2*)]
    ; is_defined= true
    ; loc= Cast.java:97
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    #n2:
      
    
    { proc_name= Cast$Supertype.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Supertype*)]
    ; is_defined= true
    ; loc= Cast.java:4
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    #n2:
      
    
    { proc_name= Cast$Subtype.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Subtype*)]
    ; is_defined= true
    ; loc= Cast.java:71
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    #n2:
      
    
    { proc_name= Cast.<init>()
    ; translation_unit= Cast.java
    ; access= Public
    ; formals= [(this,Cast*)]
    ; is_defined= true
    ; loc= Cast.java:3
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 100];
      
    #n2:
      
    
    { proc_name= Cast$Sub3.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub3*)]
    ; is_defined= true
    ; loc= Cast.java:99
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 99];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 99];
      NULLIFY(&this); [line 99];
      EXIT_SCOPE(n$0,n$1,this); [line 99];
      
    #n5:
      APPLY_ABSTRACTION; [line 99];
      
    #n2:
      
    
    { proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
    ; translation_unit= Cast.java
    ; access= Protected
    ; exceptions= [java.io.IOException]
    ; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
    ; is_defined= true
    ; loc= Cast.java:58
    ; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
               { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
    ; ret_type= Cast$Subtype* 
    ; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    #n2:
      
    
    v13=============
conditions: {[v11] = 0}∧{[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v12] ≠ 0}
       phi: linear_eqs: v11 = 0 ∧ v13 = a1 +1
            && term_eqs: 0=v11∧Cast$Sub2.<init>()([v13])=v15∧[a1 +1]=v13
                         ∧((v5 instanceof Cast$Sub1))=v11∧((v5 instanceof Cast$Sub2))=v12
                         ∧((v5 instanceof Cast$Subtype))=v8
            && intervals: v5≠null ∧ v8≠0 ∧ v11=null ∧ v12≠0 ∧ v13≥1
            && atoms: {(v5 instanceof Cast$Sub1) = 0}∧{[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v12] ≠ 0}
       { roots={ n$5=v13, &base=v2, &this=v1, &$irvar0=v26 };
         mem  ={ v1 -> { * -> v4 },
                 v2 -> { * -> v5 },
                 v3 -> { * -> v5 },
                 v4 -> { * -> v6 },
                 v13 -> { * -> v14 },
                 v26 -> { * -> v13 } };
         attrs={ v1 -> { MustBeValid(, None, t=0) },
                 v2 -> { MustBeValid(, None, t=0) },
                 v3 -> { s&destination (variable `destination` declared here at line 58 :t0 ) at line 68,
                         MustBeValid(, None, t=2),
                         WrittenTo (2, ) },
                 v4 -> { DynamicType Cast$Supertype, SourceFile [None], MustBeValid(, None, t=0) },
                 v5 -> { StaticType class Cast$Supertype },
                 v13 -> { DynamicType Cast$Sub2, SourceFile [None],
                          UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                        in call to `Cast$Subtype Cast$Subtype.create(Cast$Supertype)` at line 68 :t11
                                        [in call to `Cast$Sub2.<init>()` at line 89 :t16
                                         [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                          [] ]
                                         ]
                                        ) },
                 v26 -> { MustBeValid(, None, t=12), WrittenTo (12, ) } };}
       PRE=[{ roots={ &base=v2, &this=v1 };
              mem  ={ v1 -> { * -> v4 },
                      v2 -> { * -> v5 },
                      v4 -> { * -> v6 },
                      v5 -> { },
                      v6 -> { } };
              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                      v4 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                      v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
       need_closure_specialization=false
       need_dynamic_type_specialization={ }
       skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
       Topl={len=0;content=
              [  ]}v17=============
conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                      phi: linear_eqs: v17 = a2 +1
                           && term_eqs: Cast$Sub1.<init>()([v17])=v19
                                        ∧[a2 +1]=v17∧((v5 instanceof Cast$Sub1))=v16
                                        ∧((v5 instanceof Cast$Subtype))=v8
                           && intervals: v5≠null ∧ v8≠0 ∧ v16≠0 ∧ v17≥1
                           && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                      { roots={ n$5=v17, &base=v2, &this=v1, &$irvar0=v27 };
                        mem  ={ v1 -> { * -> v4 },
                                v2 -> { * -> v5 },
                                v3 -> { * -> v5 },
                                v4 -> { * -> v6 },
                                v17 -> { * -> v18 },
                                v27 -> { * -> v17 } };
                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                v2 -> { MustBeValid(, None, t=0) },
                                v3 -> { s&destination (variable `destination` declared here at line 58 :t0
                                                       ) at line 68,
                                        MustBeValid(, None, t=2),
                                        WrittenTo (2, ) },
                                v4 -> { DynamicType Cast$Supertype, SourceFile [None],
                                        MustBeValid(, None, t=0) },
                                v5 -> { StaticType class Cast$Supertype },
                                v17 -> { DynamicType Cast$Sub1, SourceFile [None],
                                         UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                       in call to `Cast$Subtype Cast$Subtype.create(Cast$Supertype)` at line 68 :t11
                                                       [in call to `Cast$Sub1.<init>()` at line 85 :t12
                                                        [in call to function `Cast$Sub1.<init>()` with no summary at line 98 :t2
                                                         [] ]
                                                        ]
                                                       ) },
                                v27 -> { MustBeValid(, None, t=12), WrittenTo (12, ) } };}
                      PRE=[{ roots={ &base=v2, &this=v1 };
                             mem  ={ v1 -> { * -> v4 },
                                     v2 -> { * -> v5 },
                                     v4 -> { * -> v6 },
                                     v5 -> { },
                                     v6 -> { } };
                             attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                     v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                     v4 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                     v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                      need_closure_specialization=false
                      need_dynamic_type_specialization={ }
                      skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                      Topl={len=0;content=
                             [  ]}v5=============
conditions: {[v5] = 0}∧{[v8] ≠ 0}
                                    phi: linear_eqs: v5 = 0
                                         && term_eqs: 0=v5∧((v5 instanceof Cast$Subtype))=v8
                                         && intervals: v5=null ∧ v8≠0
                                         && atoms: {[v8] ≠ 0}
                                    { roots={ n$5=v5, &base=v2, &this=v1, &$irvar0=v28 };
                                      mem  ={ v1 -> { * -> v4 },
                                              v2 -> { * -> v5 },
                                              v3 -> { * -> v5 },
                                              v4 -> { * -> v6 },
                                              v28 -> { * -> v5 } };
                                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                                              v2 -> { MustBeValid(, None, t=0) },
                                              v3 -> { s&destination (variable `destination` declared here at line 58 :t0
                                                                    ) at line 68,
                                                      MustBeValid(, None, t=2),
                                                      WrittenTo (2, ) },
                                              v4 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                      MustBeValid(, None, t=0) },
                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                      StaticType class Cast$Supertype },
                                              v28 -> { MustBeValid(, None, t=12),
                                                       WrittenTo (12, ) } };}
                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                           mem  ={ v1 -> { * -> v4 },
                                                   v2 -> { * -> v5 },
                                                   v4 -> { * -> v6 },
                                                   v5 -> { },
                                                   v6 -> { } };
                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                           MustBeValid(, None, t=0) },
                                                   v2 -> { MustBeInitialized(, t=0),
                                                           MustBeValid(, None, t=0) },
                                                   v4 -> { MustBeInitialized(, t=0),
                                                           MustBeValid(, None, t=0) },
                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                    need_closure_specialization=false
                                    need_dynamic_type_specialization=
                                    { }
                                    skipped_calls={ }
                                    Topl={len=0;content=
                                           [  ]}v5=============
conditions: {[v5] = 0}∧{[v10] = 0}
                                                  phi: var_eqs: v5=v10
                                                       && linear_eqs: 
                                                       v5 = 0
                                                       && term_eqs: 0=v10
                                                                    ∧((v5 instanceof Cast$Subtype))=v10
                                                       && intervals: 
                                                       v5=null ∧ v10=0
                                                  { roots={ n$5=v5,
                                                            &base=v2,
                                                            &this=v1,
                                                            &$irvar0=v35 };
                                                    mem  ={ v1 -> { * -> v4 },
                                                            v2 -> { * -> v5 },
                                                            v3 -> { * -> v5 },
                                                            v4 -> { * -> v6 },
                                                            v35 -> { * -> v5 } };
                                                    attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                            v2 -> { MustBeValid(, None, t=0) },
                                                            v3 -> { s&destination (variable `destination` declared here at line 58 :t0
                                                                    ) at line 68,
                                                                    MustBeValid(, None, t=2),
                                                                    WrittenTo (2, ) },
                                                            v4 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                                    MustBeValid(, None, t=0) },
                                                            v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype },
                                                            v35 -> { MustBeValid(, None, t=12),
                                                                    WrittenTo (12, ) } };}
                                                  PRE=[{ roots={ &base=v2, &this=v1 };
                                                         mem  ={ v1 -> { * -> v4 },
                                                                 v2 -> { * -> v5 },
                                                                 v4 -> { * -> v6 },
                                                                 v5 -> { },
                                                                 v6 -> { } };
                                                         attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                 v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                 v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                 v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                  need_closure_specialization=false
                                                  need_dynamic_type_specialization=
                                                  { }
                                                  skipped_calls={ }
                                                  Topl={len=0;content=
                                                         [  ]}
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 98];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 98];
      NULLIFY(&this); [line 98];
      EXIT_SCOPE(n$0,n$1,this); [line 98];
      
    #n5:
      APPLY_ABSTRACTION; [line 98];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 98 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 98 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 98 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 98 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Cast.<init>()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast*)]
; is_defined= true
; loc= Cast.java:3
; locals= []
; ret_type= void 
; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 100];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:99
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 99];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 99];
      NULLIFY(&this); [line 99];
      EXIT_SCOPE(n$0,n$1,this); [line 99];
      
    #n5:
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 99 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 99 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 99 -> { 2 } } } }
{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:102
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 102];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 102];
      NULLIFY(&this); [line 102];
      EXIT_SCOPE(n$0,n$1,this); [line 102];
      
    #n5:
      APPLY_ABSTRACTION; [line 102];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 102 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 102 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 102 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 102 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test(Object)
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*);  (a,java.lang.Object*)]
; is_defined= true
; loc= Cast.java:98
; locals= []
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test(java.lang.Object):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:java.lang.Object* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class java.lang.Object },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class java.lang.Object },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
passed to: { }{ proc_name= Cast.<init>()
                                  ; translation_unit= Cast.java
                                  ; access= Public
                                  ; formals= [(this,Cast*)]
                                  ; is_defined= true
                                  ; loc= Cast.java:3
                                  ; locals= []
                                  ; ret_type= void 
                                  ; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 104];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:103
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 103];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(n$0,n$1,this); [line 103];
      
    #n5:
      APPLY_ABSTRACTION; [line 103];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 103 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 103 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 103 -> { 2 } } } }
{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:106
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 106];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 106];
      NULLIFY(&this); [line 106];
      EXIT_SCOPE(n$0,n$1,this); [line 106];
      
    #n5:
      APPLY_ABSTRACTION; [line 106];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 106 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 106 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 106 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 106 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= void Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= void 
; proc_id= Cast$Sub2.test2():void }
    #n1:
      
    #n4:
      n$0=_fun___new(sizeof(t=java.lang.Object):java.lang.Object*) [line 103];
      n$1=_fun_Object.<init>()(n$0:java.lang.Object*) [line 103];
      *&$irvar0:java.lang.Object*=n$0 [line 103];
      EXIT_SCOPE(n$0,n$1); [line 103];
      
    #n5:
      n$2=*&this:Cast$Sub2* [line 103];
      _=*n$2:Cast$Sub2 [line 103];
      n$4=*&$irvar0:java.lang.Object* [line 103];
      n$5=_fun_Object Cast$Sub2.test(Object)(n$2:Cast$Sub2*,n$4:java.lang.Object*) virtual [line 103];
      *&a:java.lang.Object*=n$5 [line 103];
      NULLIFY(&a); [line 103];
      NULLIFY(&this); [line 103];
      NULLIFY(&$irvar0); [line 103];
      EXIT_SCOPE(_,n$2,n$4,n$5,a,this,$irvar0); [line 103];
      
    #n6:
      APPLY_ABSTRACTION; [line 104];
      
    #n2:
      
    
    { proc_name= Object Cast$Sub2.test(Object)
    ; translation_unit= Cast.java
    ; access= Public
    ; formals= [(this,Cast$Sub2*);  (a,java.lang.Object*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= java.lang.Object* 
    ; proc_id= Cast$Sub2.test(java.lang.Object):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:java.lang.Object* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class java.lang.Object },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class java.lang.Object },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
process analysis
passed to: { }Cast$Sub2.test21 disjuncts:
                                                 #0: (conditions: {[v6] ≠ 0}
                                                      phi: linear_eqs: 
                                                           v6 = a1 +1
                                                           && term_eqs: 
                                                           Object.<init>()([v6])=v7
                                                           ∧[a1 +1]=v6
                                                           && intervals: 
                                                           v6≥1
                                                           && atoms: 
                                                           {[v6] ≠ 0}
                                                      { roots={ &this=v1 };
                                                        mem  ={ v1 -> { * -> v3 },
                                                                v2 -> { * -> v6 },
                                                                v3 -> { * -> v4 },
                                                                v8 -> { * -> v6 } };
                                                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                                v2 -> { s&a (variable `a` declared here at line 102 :t0
                                                                    ) at line 103,
                                                                    MustBeValid(, None, t=9),
                                                                    WrittenTo (9, ) },
                                                                v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                                                    MustBeValid(, None, t=0) },
                                                                v6 -> { DynamicType java.lang.Object, SourceFile [None],
                                                                    StaticType class java.lang.Object,
                                                                    UnknownEffect(function `Object.<init>()` with no summary,
                                                                    in call to function `Object.<init>()` with no summary at line 103 :t2
                                                                    [
                                                                    ] ) },
                                                                v8 -> { MustBeValid(, None, t=3),
                                                                    WrittenTo (3, ) } };}
                                                      PRE=[{ roots={ &this=v1 };
                                                             mem  ={ v1 -> { * -> v3 },
                                                                    v3 -> { * -> v4 },
                                                                    v4 -> { } };
                                                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                    v3 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) } };}]
                                                      need_closure_specialization=false
                                                      need_dynamic_type_specialization=
                                                      { }
                                                      skipped_calls={ Object.<init>() -> call to skipped function occurs here }
                                                      Topl={len=0;content=
                                                             [  ]},
                                                     conditions= [] timestamp= 16)
                                                 
                                                 Non-disj state:
                                                   copy map: { }, parameter map: { },
                                                   destructor checked: { }, 
                                                   captured: { }, locked: false,
                                                   loads: ({ n$2 -> { this }, n$4 -> { $irvar0 } },
                                                   { this -> { line 103 -> { 5 } },
                                                     $irvar0 -> { line 103 -> { 7 } } }),
                                                   passed to: { this -> { Object Cast$Sub2.test(Object) -> { line 103 -> { 8 } } },
                                                                $irvar0 -> { Object Cast$Sub2.test(Object) -> { line 103 -> { 8 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Cast.<init>()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast*)]
; is_defined= true
; loc= Cast.java:3
; locals= []
; ret_type= void 
; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:107
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:106
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 106];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 106];
      NULLIFY(&this); [line 106];
      EXIT_SCOPE(n$0,n$1,this); [line 106];
      
    #n5:
      APPLY_ABSTRACTION; [line 106];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 106 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 106 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 106 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 106 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= void Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= void 
; proc_id= Cast$Sub2.test2():void }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 103];
      _=*n$0:Cast$Sub2 [line 103];
      n$2=_fun_Object Cast$Sub2.test(Object)(n$0:Cast$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:java.lang.Object*=n$2 [line 103];
      NULLIFY(&a); [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,a,this); [line 103];
      
    #n5:
      APPLY_ABSTRACTION; [line 104];
      
    #n2:
      
    
    { proc_name= Object Cast$Sub2.test(Object)
    ; translation_unit= Cast.java
    ; access= Public
    ; formals= [(this,Cast$Sub2*);  (a,java.lang.Object*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= java.lang.Object* 
    ; proc_id= Cast$Sub2.test(java.lang.Object):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:java.lang.Object* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class java.lang.Object },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class java.lang.Object },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
process analysis
passed to: { }Cast$Sub2.test21 disjuncts:
                                                 #0: (conditions: (empty)
                                                      phi: linear_eqs: 
                                                           v5 = 0
                                                           && term_eqs: 
                                                           0=v5
                                                           && intervals: 
                                                           v5=null
                                                      { roots={ &this=v1 };
                                                        mem  ={ v1 -> { * -> v3 },
                                                                v2 -> { * -> v5 },
                                                                v3 -> { * -> v4 } };
                                                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                                v2 -> { s&a (variable `a` declared here at line 102 :t0
                                                                    ) at line 103,
                                                                    MustBeValid(, None, t=4),
                                                                    WrittenTo (4, ) },
                                                                v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                                                    MustBeValid(, None, t=0) },
                                                                v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class java.lang.Object } };}
                                                      PRE=[{ roots={ &this=v1 };
                                                             mem  ={ v1 -> { * -> v3 },
                                                                    v3 -> { * -> v4 },
                                                                    v4 -> { } };
                                                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                    v3 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) } };}]
                                                      need_closure_specialization=false
                                                      need_dynamic_type_specialization=
                                                      { }
                                                      skipped_calls={ }
                                                      Topl={len=0;content=
                                                             [  ]},
                                                     conditions= [] timestamp= 10)
                                                 
                                                 Non-disj state:
                                                   copy map: { }, parameter map: { },
                                                   destructor checked: { }, 
                                                   captured: { }, locked: false,
                                                   loads: ({ n$0 -> { this } },
                                                   { this -> { line 103 -> { 1 } } }),
                                                   passed to: { this -> { Object Cast$Sub2.test(Object) -> { line 103 -> { 3 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Cast.<init>()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast*)]
; is_defined= true
; loc= Cast.java:3
; locals= []
; ret_type= void 
; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:107
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:107
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test(Object)
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*);  (a,java.lang.Object*)]
; is_defined= true
; loc= Cast.java:98
; locals= []
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test(java.lang.Object):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:java.lang.Object* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class java.lang.Object },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class java.lang.Object },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
passed to: { }{ proc_name= Cast.<init>()
                                  ; translation_unit= Cast.java
                                  ; access= Public
                                  ; formals= [(this,Cast*)]
                                  ; is_defined= true
                                  ; loc= Cast.java:3
                                  ; locals= []
                                  ; ret_type= void 
                                  ; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 109];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:108
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 108];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 108];
      NULLIFY(&this); [line 108];
      EXIT_SCOPE(n$0,n$1,this); [line 108];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 108 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 108 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 108 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test2():java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 103];
      _=*n$0:Cast$Sub2 [line 103];
      n$2=_fun_Object Cast$Sub2.test(Object)(n$0:Cast$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:java.lang.Object*=n$2 [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,this); [line 103];
      
    #n5:
      n$3=*&a:java.lang.Object* [line 104];
      *&return:java.lang.Object*=n$3 [line 104];
      NULLIFY(&a); [line 104];
      EXIT_SCOPE(n$3,a); [line 104];
      APPLY_ABSTRACTION; [line 104];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test21 disjuncts:
                   #0: (conditions: (empty)
                        phi: linear_eqs: v5 = 0 && term_eqs: 0=v5 && intervals: v5=null
                        { roots={ &this=v1, &return=v6 };
                          mem  ={ v1 -> { * -> v3 },
                                  v2 -> { * -> v5 },
                                  v3 -> { * -> v4 },
                                  v6 -> { * -> v5 } };
                          attrs={ v1 -> { MustBeValid(, None, t=0) },
                                  v2 -> { s&a (variable `a` declared here at line 102 :t0 ) at line 104,
                                          MustBeValid(, None, t=4),
                                          WrittenTo (4, ) },
                                  v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                          MustBeValid(, None, t=0) },
                                  v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                          StaticType class java.lang.Object },
                                  v6 -> { MustBeValid(, None, t=8), WrittenTo (8, ) } };}
                        PRE=[{ roots={ &this=v1 };
                               mem  ={ v1 -> { * -> v3 }, v3 -> { * -> v4 }, v4 -> { } };
                               attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                       v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                        need_closure_specialization=false
                        need_dynamic_type_specialization={ }
                        skipped_calls={ }
                        Topl={len=0;content=
                               [  ]},
                       conditions= [] timestamp= 13)
                   
                   Non-disj state:
                     copy map: { }, parameter map: { }, destructor checked: { }, 
                     captured: { }, locked: false,
                     loads: ({ n$0 -> { this }, n$3 -> { a } },
                     { a -> { line 104 -> { 7 } }, this -> { line 103 -> { 1 } } }),
                     passed to: { this -> { Object Cast$Sub2.test(Object) -> { line 103 -> { 3 } } } }process analysis end

{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:107
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= void Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= void 
; proc_id= Cast$Sub2.test2():void }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 103];
      _=*n$0:Cast$Sub2 [line 103];
      n$2=_fun_Object Cast$Sub2.test(Object)(n$0:Cast$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:java.lang.Object*=n$2 [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,this); [line 103];
      
    #n5:
      n$3=*&a:java.lang.Object* [line 104];
      _=*n$3:java.lang.Object [line 104];
      n$5=_fun_String Object.toString()(n$3:java.lang.Object*) virtual [line 104];
      *&$irvar0:java.lang.String*=n$5 [line 104];
      NULLIFY(&a); [line 104];
      NULLIFY(&$irvar0); [line 104];
      EXIT_SCOPE(_,n$3,n$5,a,$irvar0); [line 104];
      
    #n6:
      APPLY_ABSTRACTION; [line 105];
      
    #n2:
      
    
    { proc_name= Object Cast$Sub2.test(Object)
    ; translation_unit= Cast.java
    ; access= Public
    ; formals= [(this,Cast$Sub2*);  (a,java.lang.Object*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= java.lang.Object* 
    ; proc_id= Cast$Sub2.test(java.lang.Object):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:java.lang.Object* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class java.lang.Object },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class java.lang.Object },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
process analysis
passed to: { }Cast$Sub2.test21 disjuncts:
                                                 #0: ({AbortProgram conditions: (empty)
                                                                    phi: 
                                                                    (empty)
                                                                    {
                                                                     roots=
                                                                    { &this=v1 };
                                                                    mem  =
                                                                    { v1 -> { * -> v3 },
                                                                    v3 -> { * -> v4 } };
                                                                    attrs=
                                                                    { v3 -> { DynamicType Cast$Sub2, SourceFile [None] } };}
                                                                    PRE=[{
                                                                     roots=
                                                                    { &this=v1 };
                                                                    mem  =
                                                                    { v1 -> { * -> v3 },
                                                                    v3 -> { * -> v4 } };
                                                                    attrs=
                                                                    { v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                    v3 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) } };}]
                                                                    need_closure_specialization=false
                                                                    need_dynamic_type_specialization=
                                                                    { }
                                                                    skipped_calls=
                                                                    { }
                                                                    Topl=
                                                                    {len=0;content=
                                                                    [  ]}},
                                                     conditions= [] timestamp= 16)
                                                 process analysis end

                                                 Non-disj state: ⊤{ proc_name= Cast$Subtype.<init>()
                                                                    ; translation_unit= Cast.java
                                                                    ; formals= [
                                                                    (this,Cast$Subtype*)]
                                                                    ; is_defined= true
                                                                    ; loc= Cast.java:71
                                                                    ; locals= [
                                                                    ]
                                                                    ; ret_type= void 
                                                                    ; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Cast.<init>()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast*)]
; is_defined= true
; loc= Cast.java:3
; locals= []
; ret_type= void 
; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 109];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:108
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 108];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 108];
      NULLIFY(&this); [line 108];
      EXIT_SCOPE(n$0,n$1,this); [line 108];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 108 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 108 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 108 -> { 2 } } } }
{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }

Cast.java:104: error: Null Dereference
  `a` could be null (null value originating from line 103) and is dereferenced. 
  102.           public void test2() {
  103.               Object a = test(null);
  104. >             a.toString();
  105.           }
  106.       }


Found 2 issues
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
                   Null Dereference(NULLPTR_DEREFERENCE): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:107
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test(Object)
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*);  (a,java.lang.Object*)]
; is_defined= true
; loc= Cast.java:98
; locals= []
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test(java.lang.Object):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:java.lang.Object* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:java.lang.Object* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class java.lang.Object },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class java.lang.Object },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Object), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
passed to: { }{ proc_name= Cast.<init>()
                                  ; translation_unit= Cast.java
                                  ; access= Public
                                  ; formals= [(this,Cast*)]
                                  ; is_defined= true
                                  ; loc= Cast.java:3
                                  ; locals= []
                                  ; ret_type= void 
                                  ; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 109];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:108
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 108];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 108];
      NULLIFY(&this); [line 108];
      EXIT_SCOPE(n$0,n$1,this); [line 108];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 108 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 108 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 108 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test2():java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 103];
      _=*n$0:Cast$Sub2 [line 103];
      n$2=_fun_Object Cast$Sub2.test(Object)(n$0:Cast$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:java.lang.Object*=n$2 [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,this); [line 103];
      
    #n5:
      n$3=*&a:java.lang.Object* [line 104];
      *&return:java.lang.Object*=n$3 [line 104];
      NULLIFY(&a); [line 104];
      EXIT_SCOPE(n$3,a); [line 104];
      APPLY_ABSTRACTION; [line 104];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test21 disjuncts:
                   #0: (conditions: (empty)
                        phi: linear_eqs: v5 = 0 && term_eqs: 0=v5 && intervals: v5=null
                        { roots={ &this=v1, &return=v6 };
                          mem  ={ v1 -> { * -> v3 },
                                  v2 -> { * -> v5 },
                                  v3 -> { * -> v4 },
                                  v6 -> { * -> v5 } };
                          attrs={ v1 -> { MustBeValid(, None, t=0) },
                                  v2 -> { s&a (variable `a` declared here at line 102 :t0 ) at line 104,
                                          MustBeValid(, None, t=4),
                                          WrittenTo (4, ) },
                                  v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                          MustBeValid(, None, t=0) },
                                  v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                          StaticType class java.lang.Object },
                                  v6 -> { MustBeValid(, None, t=8), WrittenTo (8, ) } };}
                        PRE=[{ roots={ &this=v1 };
                               mem  ={ v1 -> { * -> v3 }, v3 -> { * -> v4 }, v4 -> { } };
                               attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                       v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                        need_closure_specialization=false
                        need_dynamic_type_specialization={ }
                        skipped_calls={ }
                        Topl={len=0;content=
                               [  ]},
                       conditions= [] timestamp= 13)
                   
                   Non-disj state:
                     copy map: { }, parameter map: { }, destructor checked: { }, 
                     captured: { }, locked: false,
                     loads: ({ n$0 -> { this }, n$3 -> { a } },
                     { a -> { line 104 -> { 7 } }, this -> { line 103 -> { 1 } } }),
                     passed to: { this -> { Object Cast$Sub2.test(Object) -> { line 103 -> { 3 } } } }process analysis end

{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:107
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*);  (a,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:98
; locals= []
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test(Cast$Supertype):java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&a:Cast$Supertype* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:java.lang.Object*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:Cast$Supertype* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:Cast$Supertype* [line 99];
      *&return:java.lang.Object*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class Cast$Supertype },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Cast$Supertype), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class Cast$Supertype },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Object Cast$Sub2.test(Cast$Supertype), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
passed to: { }{ proc_name= Cast.<init>()
                                  ; translation_unit= Cast.java
                                  ; access= Public
                                  ; formals= [(this,Cast*)]
                                  ; is_defined= true
                                  ; loc= Cast.java:3
                                  ; locals= []
                                  ; ret_type= void 
                                  ; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 109];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:108
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 108];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 108];
      NULLIFY(&this); [line 108];
      EXIT_SCOPE(n$0,n$1,this); [line 108];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 108 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 108 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 108 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test2():java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 103];
      _=*n$0:Cast$Sub2 [line 103];
      n$2=_fun_Object Cast$Sub2.test(Cast$Supertype)(n$0:Cast$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:java.lang.Object*=n$2 [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,this); [line 103];
      
    #n5:
      n$3=*&a:java.lang.Object* [line 104];
      *&return:java.lang.Object*=n$3 [line 104];
      NULLIFY(&a); [line 104];
      EXIT_SCOPE(n$3,a); [line 104];
      APPLY_ABSTRACTION; [line 104];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test21 disjuncts:
                   #0: (conditions: (empty)
                        phi: linear_eqs: v5 = 0 && term_eqs: 0=v5 && intervals: v5=null
                        { roots={ &this=v1, &return=v6 };
                          mem  ={ v1 -> { * -> v3 },
                                  v2 -> { * -> v5 },
                                  v3 -> { * -> v4 },
                                  v6 -> { * -> v5 } };
                          attrs={ v1 -> { MustBeValid(, None, t=0) },
                                  v2 -> { s&a (variable `a` declared here at line 102 :t0 ) at line 104,
                                          MustBeValid(, None, t=4),
                                          WrittenTo (4, ) },
                                  v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                          MustBeValid(, None, t=0) },
                                  v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                          StaticType class Cast$Supertype },
                                  v6 -> { MustBeValid(, None, t=8), WrittenTo (8, ) } };}
                        PRE=[{ roots={ &this=v1 };
                               mem  ={ v1 -> { * -> v3 }, v3 -> { * -> v4 }, v4 -> { } };
                               attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                       v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                        need_closure_specialization=false
                        need_dynamic_type_specialization={ }
                        skipped_calls={ }
                        Topl={len=0;content=
                               [  ]},
                       conditions= [] timestamp= 13)
                   
                   Non-disj state:
                     copy map: { }, parameter map: { }, destructor checked: { }, 
                     captured: { }, locked: false,
                     loads: ({ n$0 -> { this }, n$3 -> { a } },
                     { a -> { line 104 -> { 7 } }, this -> { line 103 -> { 1 } } }),
                     passed to: { this -> { Object Cast$Sub2.test(Cast$Supertype) -> { line 103 -> { 3 } } } }process analysis end

{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Subtype Cast$Subtype.create(Cast$Supertype)
; translation_unit= Cast.java
; access= Public
; exceptions= [java.io.IOException]
; formals= [(base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:73
; locals= [{ name= $irvar2; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar1; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= retval; typ= Cast$Subtype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Subtype.create(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      *&retval:java.lang.Object*=null [line 75];
      
    #n5:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE(!(n$0 != null), true); [line 76];
      NULLIFY(&base); [line 76];
      EXIT_SCOPE(n$0,base); [line 76];
      
    #n7:
      n$1=*&retval:java.lang.Object* [line 78];
      *&return:Cast$Subtype*=n$1 [line 78];
      NULLIFY(&retval); [line 78];
      EXIT_SCOPE(n$1,retval); [line 78];
      APPLY_ABSTRACTION; [line 78];
      
    #n6:
      n$0=*&base:Cast$Supertype* [line 76];
      PRUNE((n$0 != null), false); [line 76];
      NULLIFY(&retval); [line 76];
      EXIT_SCOPE(n$0,retval); [line 76];
      
    #n8:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE(!(n$3 == 0), true); [line 83];
      NULLIFY(&base); [line 83];
      EXIT_SCOPE(n$2,n$3,base); [line 83];
      
    #n10:
      n$4=_fun___new(sizeof(t=Cast$Sub1):Cast$Sub1*) [line 85];
      n$5=_fun_Cast$Sub1.<init>()(n$4:Cast$Sub1*) [line 85];
      *&retval:Cast$Sub1*=n$4 [line 85];
      EXIT_SCOPE(n$4,n$5); [line 85];
      APPLY_ABSTRACTION; [line 85];
      
    #n9:
      n$2=*&base:Cast$Supertype* [line 83];
      n$3=_fun___instanceof(n$2:Cast$Supertype*,sizeof(t=Cast$Sub1):void) [line 83];
      PRUNE((n$3 == 0), false); [line 83];
      EXIT_SCOPE(n$2,n$3); [line 83];
      
    #n11:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE(!(n$7 == 0), true); [line 87];
      NULLIFY(&base); [line 87];
      EXIT_SCOPE(n$6,n$7,base); [line 87];
      
    #n13:
      n$8=_fun___new(sizeof(t=Cast$Sub2):Cast$Sub2*) [line 89];
      n$9=_fun_Cast$Sub2.<init>()(n$8:Cast$Sub2*) [line 89];
      *&retval:Cast$Sub2*=n$8 [line 89];
      EXIT_SCOPE(n$8,n$9); [line 89];
      APPLY_ABSTRACTION; [line 89];
      
    #n18:
      n$19=*&retval:Cast$Sub2* [line 95];
      *&return:Cast$Subtype*=n$19 [line 95];
      NULLIFY(&retval); [line 95];
      EXIT_SCOPE(n$19,retval); [line 95];
      APPLY_ABSTRACTION; [line 95];
      
    #n2:
      
    #n12:
      n$6=*&base:Cast$Supertype* [line 87];
      n$7=_fun___instanceof(n$6:Cast$Supertype*,sizeof(t=Cast$Sub2):void) [line 87];
      PRUNE((n$7 == 0), false); [line 87];
      EXIT_SCOPE(n$6,n$7); [line 87];
      
    #n14:
      n$10=*&base:Cast$Supertype* [line 93];
      n$11=_fun_String String.valueOf(Object)(n$10:Cast$Supertype*) [line 93];
      *&$irvar0:java.lang.String*=n$11 [line 93];
      NULLIFY(&base); [line 93];
      EXIT_SCOPE(n$10,n$11,base); [line 93];
      
    #n15:
      n$12=*&$irvar0:java.lang.String* [line 93];
      n$13=_fun_String Object.makeConcatWithConstants(String)(n$12:java.lang.String*) [line 93];
      *&$irvar1:java.lang.String*=n$13 [line 93];
      NULLIFY(&$irvar0); [line 93];
      EXIT_SCOPE(n$12,n$13,$irvar0); [line 93];
      
    #n16:
      n$14=_fun___new(sizeof(t=java.io.IOException):java.io.IOException*) [line 93];
      n$15=*&$irvar1:java.lang.String* [line 93];
      n$16=_fun_IOException.<init>(String)(n$14:java.io.IOException*,n$15:java.lang.String*) [line 93];
      *&$irvar2:java.io.IOException*=n$14 [line 93];
      NULLIFY(&$irvar1); [line 93];
      EXIT_SCOPE(n$14,n$15,n$16,$irvar1); [line 93];
      
    #n17:
      n$17=*&$irvar2:java.io.IOException* [line 93];
      *&return:Cast$Subtype*=EXN n$17 [line 93];
      n$18=_fun___java_throw() [line 93];
      NULLIFY(&$irvar2); [line 93];
      EXIT_SCOPE(n$17,n$18,$irvar2); [line 93];
      
    
    { proc_name= Cast$Sub1.<init>()
    ; translation_unit= Cast.java
    ; formals= [(this,Cast$Sub1*)]
    ; is_defined= true
    ; loc= Cast.java:107
    ; locals= []
    ; ret_type= void 
    ; proc_id= Cast$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub1* [line 107];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub1*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Sub1.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub1.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub1, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                                         in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 107 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub1.<init>() -> { line 107 -> { 2 } } } }
{ proc_name= Cast$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 97];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Sub2.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub2.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub2, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                                         in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 97 -> { 1 } } }),
                      process analysis end
process analysis
passed to: { this -> { Cast$Sub2.<init>() -> { line 97 -> { 2 } } } }Cast$Subtype.create
3 disjuncts:
#0: (conditions: {[v3] = 0}
     phi: var_eqs: v3=v4 && linear_eqs: v3 = 0 && term_eqs: 0=v4 && intervals: v3=null ∧ v4=null
     { roots={ &base=v1, &return=v5 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v4 }, v5 -> { * -> v3 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 78,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v5 -> { MustBeValid(, None, t=7), WrittenTo (7, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 12)
#1: (conditions: {[v3] ≠ 0}∧{[v7] ≠ 0}
     phi: linear_eqs: v4 = 0 ∧ v9 = a1 +1
          && term_eqs: 0=v4∧Cast$Sub1.<init>()([v9])=v11∧[a1 +1]=v9
                       ∧((v3 instanceof Cast$Sub1))=v7
          && intervals: v3≠null ∧ v4=null ∧ v7≠0 ∧ v9≥1
          && atoms: {[v3] ≠ 0}∧{[v7] ≠ 0}
     { roots={ &base=v1, &return=v22 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v9 -> { * -> v10 },
               v12 -> { * -> v9 },
               v22 -> { * -> v9 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v9 -> { DynamicType Cast$Sub1, SourceFile [None],
                       MustBeValid(, None, t=12),
                       UnknownEffect(function `Cast$Sub1.<init>()` with no summary,
                                     in call to `Cast$Sub1.<init>()` at line 85 :t12
                                     [in call to function `Cast$Sub1.<init>()` with no summary at line 107 :t2
                                      [] ]
                                     ) },
               v12 -> { s&retval (variable `retval` accessed here at line 85 :t13 ) at line 95,
                        MustBeValid(, None, t=13),
                        WrittenTo (13, ) },
               v22 -> { MustBeValid(, None, t=17), WrittenTo (17, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 22)
#2: (conditions: {[v14] = 0}∧{[v3] ≠ 0}∧{[v16] ≠ 0}
     phi: var_eqs: v4=v14
          && linear_eqs: v4 = 0 ∧ v18 = a2 +1
          && term_eqs: 0=v4∧Cast$Sub2.<init>()([v18])=v20∧[a2 +1]=v18
                       ∧((v3 instanceof Cast$Sub1))=v14∧((v3 instanceof Cast$Sub2))=v16
          && intervals: v3≠null ∧ v4=null ∧ v14=0 ∧ v16≠0 ∧ v18≥1
          && atoms: {[v3] ≠ 0}∧{[v16] ≠ 0}
     { roots={ &base=v1, &return=v23 };
       mem  ={ v1 -> { * -> v3 },
               v2 -> { * -> v4 },
               v18 -> { * -> v19 },
               v21 -> { * -> v18 },
               v23 -> { * -> v18 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&retval (variable `retval` declared here at line 73 :t0 ) at line 76,
                       MustBeValid(, None, t=1),
                       WrittenTo (1, ) },
               v3 -> { StaticType class Cast$Supertype },
               v4 -> { Invalid ConstantDereference(is assigned to the null pointer) },
               v18 -> { DynamicType Cast$Sub2, SourceFile [None],
                        MustBeValid(, None, t=16),
                        UnknownEffect(function `Cast$Sub2.<init>()` with no summary,
                                      in call to `Cast$Sub2.<init>()` at line 89 :t16
                                      [in call to function `Cast$Sub2.<init>()` with no summary at line 97 :t2
                                       [] ]
                                      ) },
               v21 -> { s&retval (variable `retval` accessed here at line 89 :t17 ) at line 95,
                        MustBeValid(, None, t=17),
                        WrittenTo (17, ) },
               v23 -> { MustBeValid(, None, t=21), WrittenTo (21, ) } };}
     PRE=[{ roots={ &base=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 26)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { base },
            n$1 -> { retval },
            n$2 -> { base },
            n$6 -> { base },
            n$19 -> { retval } },
  { base -> { line 76 -> { 2 }, line 83 -> { 6 }, line 87 -> { 10 } },
    retval -> { line 78 -> { 6 }, line 95 -> { 16, 20 } } }),
  process analysis end
passed to: { base -> { __instanceof -> { line 83 -> { 7 }, line 87 -> { 11 } } } }
{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 71];
      
    process analysis
#n2:
      
    
    Cast$Subtype.<init>1 disjuncts:
                       #0: (conditions: (empty) phi: term_eqs: Cast$Subtype.<init>()([v2])=v4
                            { roots={ &this=v1 };
                              mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                              attrs={ v1 -> { MustBeValid(, None, t=0) },
                                      v2 -> { DynamicType Cast$Subtype, SourceFile [None],
                                              MustBeValid(, None, t=0),
                                              UnknownEffect(function `Cast$Subtype.<init>()` with no summary,
                                                            in call to function `Cast$Subtype.<init>()` with no summary at line 71 :t2
                                                            [] ) } };}
                            PRE=[{ roots={ &this=v1 };
                                   mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                   attrs={ v1 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) },
                                           v2 -> { MustBeInitialized(, t=0),
                                                   MustBeValid(, None, t=0) } };}]
                            need_closure_specialization=false
                            need_dynamic_type_specialization={ }
                            skipped_calls={ Cast$Subtype.<init>() -> call to skipped function occurs here }
                            Topl={len=0;content=
                                   [  ]},
                           conditions= [] timestamp= 7)
                       
                       Non-disj state:
                         copy map: { }, parameter map: { }, destructor checked: { }, 
                         captured: { }, locked: false,
                         loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                         process analysis end
passed to: { this -> { Cast$Subtype.<init>() -> { line 71 -> { 2 } } } }
{ proc_name= Cast.<init>()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast*)]
; is_defined= true
; loc= Cast.java:3
; locals= []
; ret_type= void 
; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 109];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Cast$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Sub3*)]
; is_defined= true
; loc= Cast.java:108
; locals= []
; ret_type= void 
; proc_id= Cast$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub3* [line 108];
      n$1=_fun_Cast$Subtype.<init>()(n$0:Cast$Sub3*) [line 108];
      NULLIFY(&this); [line 108];
      EXIT_SCOPE(n$0,n$1,this); [line 108];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast$Sub3.<init>1 disjuncts:
                    #0: (conditions: (empty) phi: term_eqs: Cast$Sub3.<init>()([v2])=v4
                         { roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                   v2 -> { DynamicType Cast$Sub3, SourceFile [None],
                                           MustBeValid(, None, t=0),
                                           UnknownEffect(function `Cast$Sub3.<init>()` with no summary,
                                                         in call to function `Cast$Sub3.<init>()` with no summary at line 108 :t2
                                                         [] ) } };}
                         PRE=[{ roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) },
                                        v2 -> { MustBeInitialized(, t=0),
                                                MustBeValid(, None, t=0) } };}]
                         need_closure_specialization=false
                         need_dynamic_type_specialization={ }
                         skipped_calls={ Cast$Sub3.<init>() -> call to skipped function occurs here }
                         Topl={len=0;content=
                                [  ]},
                        conditions= [] timestamp= 7)
                    
                    Non-disj state:
                      copy map: { }, parameter map: { }, destructor checked: { }, 
                      captured: { }, locked: false,
                      loads: ({ n$0 -> { this } },{ this -> { line 108 -> { 1 } } }),
                      process analysis end
passed to: { this -> { Cast$Sub3.<init>() -> { line 108 -> { 2 } } } }
{ proc_name= Object Cast$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= java.lang.Object* 
; proc_id= Cast$Sub2.test2():java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Sub2* [line 103];
      _=*n$0:Cast$Sub2 [line 103];
      n$2=_fun_Cast$Supertype Cast$Sub2.test(Cast$Supertype)(n$0:Cast$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:Cast$Supertype*=n$2 [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,this); [line 103];
      
    #n5:
      n$3=*&a:Cast$Supertype* [line 104];
      *&return:java.lang.Object*=n$3 [line 104];
      NULLIFY(&a); [line 104];
      EXIT_SCOPE(n$3,a); [line 104];
      APPLY_ABSTRACTION; [line 104];
      
    #n2:
      
    
    { proc_name= Cast$Supertype Cast$Sub2.test(Cast$Supertype)
    ; translation_unit= Cast.java
    ; access= Public
    ; formals= [(this,Cast$Sub2*);  (a,Cast$Supertype*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= Cast$Supertype* 
    ; proc_id= Cast$Sub2.test(Cast$Supertype):Cast$Supertype }
    #n1:
      
    #n4:
      n$0=*&a:Cast$Supertype* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:Cast$Supertype*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:Cast$Supertype* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:Cast$Supertype* [line 99];
      *&return:Cast$Supertype*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Sub2.test2 disjuncts:
                  #0: (conditions: {[v4] = 0}
                       phi: var_eqs: v4=v6
                            && linear_eqs: v4 = 0
                            && term_eqs: 0=v4
                            && intervals: v4=null ∧ v6=null
                       { roots={ &a=v2, &this=v1, &return=v7 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v7 -> { * -> v6 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                         StaticType class Cast$Supertype },
                                 v7 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Cast$Supertype Cast$Sub2.test(Cast$Supertype), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 8)
                  #1: (conditions: {[v4] ≠ 0} phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                       { roots={ &a=v2, &this=v1, &return=v8 };
                         mem  ={ v1 -> { * -> v3 },
                                 v2 -> { * -> v4 },
                                 v3 -> { * -> v5 },
                                 v8 -> { * -> v4 } };
                         attrs={ v1 -> { MustBeValid(, None, t=0) },
                                 v2 -> { MustBeValid(, None, t=0) },
                                 v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                         MustBeValid(, None, t=0) },
                                 v4 -> { StaticType class Cast$Supertype },
                                 v8 -> { MustBeValid(, None, t=5), WrittenTo (5, ) } };}
                       PRE=[{ roots={ &a=v2, &this=v1 };
                              mem  ={ v1 -> { * -> v3 },
                                      v2 -> { * -> v4 },
                                      v3 -> { * -> v5 },
                                      v4 -> { },
                                      v5 -> { } };
                              attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                      v4 -> { UsedAsBranchCond(Cast$Supertype Cast$Sub2.test(Cast$Supertype), line 99, ) } };}]
                       need_closure_specialization=false
                       need_dynamic_type_specialization={ }
                       skipped_calls={ }
                       Topl={len=0;content=
                              [  ]},
                      conditions= [] timestamp= 10)
                  
                  Non-disj state:
                    copy map: { }, parameter map: { }, destructor checked: { }, 
                    captured: { }, locked: false,
                    loads: ({ n$0 -> { a }, n$1 -> { a } },{ a -> { line 99 -> { 1, 4 } } }),
                    process analysis end
process analysis
passed to: { }Cast$Sub2.test21 disjuncts:
                                                 #0: (conditions: (empty)
                                                      phi: linear_eqs: 
                                                           v5 = 0
                                                           && term_eqs: 
                                                           0=v5
                                                           && intervals: 
                                                           v5=null
                                                      { roots={ &this=v1, &return=v6 };
                                                        mem  ={ v1 -> { * -> v3 },
                                                                v2 -> { * -> v5 },
                                                                v3 -> { * -> v4 },
                                                                v6 -> { * -> v5 } };
                                                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                                v2 -> { s&a (variable `a` declared here at line 102 :t0
                                                                    ) at line 104,
                                                                    MustBeValid(, None, t=4),
                                                                    WrittenTo (4, ) },
                                                                v3 -> { DynamicType Cast$Sub2, SourceFile [None],
                                                                    MustBeValid(, None, t=0) },
                                                                v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype },
                                                                v6 -> { MustBeValid(, None, t=8),
                                                                    WrittenTo (8, ) } };}
                                                      PRE=[{ roots={ &this=v1 };
                                                             mem  ={ v1 -> { * -> v3 },
                                                                    v3 -> { * -> v4 },
                                                                    v4 -> { } };
                                                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                    v3 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) } };}]
                                                      need_closure_specialization=false
                                                      need_dynamic_type_specialization=
                                                      { }
                                                      skipped_calls={ }
                                                      Topl={len=0;content=
                                                             [  ]},
                                                     conditions= [] timestamp= 13)
                                                 
                                                 Non-disj state:
                                                   copy map: { }, parameter map: { },
                                                   destructor checked: { }, 
                                                   captured: { }, locked: false,
                                                   loads: ({ n$0 -> { this }, n$3 -> { a } },
                                                   { a -> { line 104 -> { 7 } },
                                                     this -> { line 103 -> { 1 } } }),
                                                   passed to: { this -> { Cast$Supertype Cast$Sub2.test(Cast$Supertype) -> { line 103 -> { 3 } } } }process analysis end

{ proc_name= Cast$Subtype Cast$Supertype.convertCOSToPD(Cast$Supertype)
; translation_unit= Cast.java
; access= Protected
; exceptions= [java.io.IOException]
; formals= [(this,Cast$Supertype*);  (base,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:58
; locals= [{ name= $irvar0; typ= void; modify_in_block= false; is_declared_unused= false }; 
           { name= destination; typ= Cast$Supertype*; modify_in_block= false; is_declared_unused= false }]
; ret_type= Cast$Subtype* 
; proc_id= Cast$Supertype.convertCOSToPD(Cast$Supertype):Cast$Subtype }
    #n1:
      
    #n4:
      n$0=*&base:Cast$Supertype* [line 60];
      *&destination:Cast$Supertype*=n$0 [line 60];
      EXIT_SCOPE(n$0); [line 60];
      
    #n5:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE(!(n$2 == 0), true); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n6:
      n$1=*&base:Cast$Supertype* [line 61];
      n$2=_fun___instanceof(n$1:Cast$Supertype*,sizeof(t=Cast$Subtype):void) [line 61];
      PRUNE((n$2 == 0), false); [line 61];
      NULLIFY(&base); [line 61];
      EXIT_SCOPE(n$1,n$2,base); [line 61];
      APPLY_ABSTRACTION; [line 61];
      
    #n7:
      n$3=*&destination:Cast$Supertype* [line 68];
      n$4=_fun_Cast$Subtype Cast$Subtype.create(Cast$Supertype)(n$3:Cast$Supertype*) [line 68];
      *&$irvar0:Cast$Subtype*=n$4 [line 68];
      NULLIFY(&destination); [line 68];
      EXIT_SCOPE(n$3,n$4,destination); [line 68];
      
    #n8:
      n$5=*&$irvar0:Cast$Subtype* [line 68];
      n$6=_fun___cast(n$5:Cast$Subtype*,sizeof(t=Cast$Sub3):void) [line 68];
      *&return:Cast$Subtype*=n$6 [line 68];
      NULLIFY(&$irvar0); [line 68];
      EXIT_SCOPE(n$5,n$6,$irvar0); [line 68];
      APPLY_ABSTRACTION; [line 68];
      
    process analysis
#n2:
      
    
    Cast$Supertype.convertCOSToPD3 disjuncts:
                                 #0: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub2 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub2;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v11] = 0}∧{[v5] ≠ 0}
                                                 ∧{[v8] ≠ 0}∧{[v12] ≠ 0}
                                     phi: linear_eqs: v11 = 0
                                          && term_eqs: 0=v11∧((v5 instanceof Cast$Sub1))=v11
                                                       ∧((v5 instanceof Cast$Sub2))=v12
                                                       ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0
                                                         ∧ v11=null
                                                         ∧ v12≠0
                                          && atoms: {(v5 instanceof Cast$Sub1) = 0}
                                                    ∧{[v5] ≠ 0}∧{[v8] ≠ 0}
                                                    ∧{[v12] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub2.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #1: ({LatentAbortProgram(line 68: Inproper Cast at line 68, class Cast$Sub1 cannot cast to class Cast$Sub3)
                                     JavaCastError {calling_context=[
                                                    ]; class_name=class Cast$Sub1;
                                                    allocation_trace:immediate; location:line 68}
                                     conditions: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     phi: term_eqs: ((v5 instanceof Cast$Sub1))=v16
                                                    ∧((v5 instanceof Cast$Subtype))=v8
                                          && intervals: v5≠null ∧ v8≠0 ∧ v16≠0
                                          && atoms: {[v5] ≠ 0}∧{[v8] ≠ 0}∧{[v16] ≠ 0}
                                     { roots={ &base=v2, &this=v1 };
                                       mem  ={ v1 -> { * -> v4 },
                                               v2 -> { * -> v5 },
                                               v4 -> { * -> v6 } };
                                       attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                               v5 -> { StaticType class Cast$Supertype } };}
                                     PRE=[{ roots={ &base=v2, &this=v1 };
                                            mem  ={ v1 -> { * -> v4 },
                                                    v2 -> { * -> v5 },
                                                    v4 -> { * -> v6 } };
                                            attrs={ v1 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v2 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v4 -> { MustBeInitialized(, t=0),
                                                            MustBeValid(, None, t=0) },
                                                    v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                     need_closure_specialization=false
                                     need_dynamic_type_specialization=
                                     { }
                                     skipped_calls={ Cast$Sub1.<init>() -> call to skipped function occurs here }
                                     Topl={len=0;content=
                                            [  ]}},
                                     conditions= [] timestamp= 22)
                                 #2: ({AbortProgram conditions: {[v5] = 0}
                                                    phi: linear_eqs: 
                                                         v5 = 0
                                                         && term_eqs: 
                                                         0=v5
                                                         && intervals: 
                                                         v5=null
                                                    { roots={ &base=v2, &this=v1 };
                                                      mem  ={ v1 -> { * -> v4 },
                                                              v2 -> { * -> v5 },
                                                              v4 -> { * -> v6 } };
                                                      attrs={ v4 -> { DynamicType Cast$Supertype, SourceFile [None] },
                                                              v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                                    StaticType class Cast$Supertype } };}
                                                    PRE=[{ roots={ &base=v2, &this=v1 };
                                                           mem  ={ v1 -> { * -> v4 },
                                                                   v2 -> { * -> v5 },
                                                                   v4 -> { * -> v6 } };
                                                           attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v2 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v4 -> { MustBeInitialized(, t=0),
                                                                    MustBeValid(, None, t=0) },
                                                                   v5 -> { UsedAsBranchCond(Cast$Subtype Cast$Subtype.create(Cast$Supertype), line 76, ) } };}]
                                                    need_closure_specialization=false
                                                    need_dynamic_type_specialization=
                                                    { }
                                                    skipped_calls={ }
                                                    Topl={len=0;content=
                                                           [  ]}},
                                     conditions= [] timestamp= 22)
                                 process analysis end

                                 Non-disj state: ⊤
Cast.java:68: error: PULSE_CLASS_CAST_EXCEPTION
  Inproper Cast at line 68, class Cast$Supertype cannot cast to class Cast$Sub3. 
  66.               // destination = ((COSDictionary)base).getDictionaryObject( COSName.D );
  67.           }
  68. >         return (Sub3)Subtype.create( destination );
  69.       }
  70.       }


Found 1 issue
                              Issue Type(ISSUED_TYPE_ID): #
  PULSE_CLASS_CAST_EXCEPTION(PULSE_CLASS_CAST_EXCEPTION): 1
{ proc_name= Cast$Supertype$Subtype$Sub1.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype$Subtype$Sub1*)]
; is_defined= true
; loc= Cast.java:107
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype$Subtype$Sub1.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype$Subtype$Sub1* [line 107];
      n$1=_fun_Cast$Supertype$Subtype.<init>()(n$0:Cast$Supertype$Subtype$Sub1*) [line 107];
      NULLIFY(&this); [line 107];
      EXIT_SCOPE(n$0,n$1,this); [line 107];
      
    #n5:
      APPLY_ABSTRACTION; [line 107];
      
    process analysis
#n2:
      
    
    Cast$Supertype$Subtype$Sub1.<init>1 disjuncts:
                                      #0: (conditions: (empty)
                                           phi: term_eqs: Cast$Supertype$Subtype$Sub1.<init>()([v2])=v4
                                           { roots={ &this=v1 };
                                             mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                             attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                     v2 -> { DynamicType Cast$Supertype$Subtype$Sub1, SourceFile [None],
                                                             MustBeValid(, None, t=0),
                                                             UnknownEffect(function `Cast$Supertype$Subtype$Sub1.<init>()` with no summary,
                                                                    in call to function `Cast$Supertype$Subtype$Sub1.<init>()` with no summary at line 107 :t2
                                                                    [
                                                                    ] ) } };}
                                           PRE=[{ roots={ &this=v1 };
                                                  mem  ={ v1 -> { * -> v2 },
                                                          v2 -> { * -> v3 },
                                                          v3 -> { } };
                                                  attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                  MustBeValid(, None, t=0) },
                                                          v2 -> { MustBeInitialized(, t=0),
                                                                  MustBeValid(, None, t=0) } };}]
                                           need_closure_specialization=false
                                           need_dynamic_type_specialization=
                                           { }
                                           skipped_calls={ Cast$Supertype$Subtype$Sub1.<init>() -> call to skipped function occurs here }
                                           Topl={len=0;content=
                                                  [  ]},
                                          conditions= [] timestamp= 7)
                                      
                                      Non-disj state:
                                        copy map: { }, parameter map: { }, 
                                        destructor checked: { }, captured: { }, 
                                        locked: false,
                                        loads: ({ n$0 -> { this } },
                                        { this -> { line 107 -> { 1 } } }),
                                        passed to: { this -> { Cast$Supertype$Subtype$Sub1.<init>() -> { line 107 -> { 2 } } } }process analysis end

{ proc_name= Cast$Supertype$Subtype$Sub2.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype$Subtype$Sub2*)]
; is_defined= true
; loc= Cast.java:97
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype$Subtype$Sub2.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype$Subtype$Sub2* [line 97];
      n$1=_fun_Cast$Supertype$Subtype.<init>()(n$0:Cast$Supertype$Subtype$Sub2*) [line 97];
      NULLIFY(&this); [line 97];
      EXIT_SCOPE(n$0,n$1,this); [line 97];
      
    #n5:
      APPLY_ABSTRACTION; [line 97];
      
    process analysis
#n2:
      
    
    Cast$Supertype$Subtype$Sub2.<init>1 disjuncts:
                                      #0: (conditions: (empty)
                                           phi: term_eqs: Cast$Supertype$Subtype$Sub2.<init>()([v2])=v4
                                           { roots={ &this=v1 };
                                             mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                             attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                     v2 -> { DynamicType Cast$Supertype$Subtype$Sub2, SourceFile [None],
                                                             MustBeValid(, None, t=0),
                                                             UnknownEffect(function `Cast$Supertype$Subtype$Sub2.<init>()` with no summary,
                                                                    in call to function `Cast$Supertype$Subtype$Sub2.<init>()` with no summary at line 97 :t2
                                                                    [
                                                                    ] ) } };}
                                           PRE=[{ roots={ &this=v1 };
                                                  mem  ={ v1 -> { * -> v2 },
                                                          v2 -> { * -> v3 },
                                                          v3 -> { } };
                                                  attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                  MustBeValid(, None, t=0) },
                                                          v2 -> { MustBeInitialized(, t=0),
                                                                  MustBeValid(, None, t=0) } };}]
                                           need_closure_specialization=false
                                           need_dynamic_type_specialization=
                                           { }
                                           skipped_calls={ Cast$Supertype$Subtype$Sub2.<init>() -> call to skipped function occurs here }
                                           Topl={len=0;content=
                                                  [  ]},
                                          conditions= [] timestamp= 7)
                                      
                                      Non-disj state:
                                        copy map: { }, parameter map: { }, 
                                        destructor checked: { }, captured: { }, 
                                        locked: false,
                                        loads: ({ n$0 -> { this } },
                                        { this -> { line 97 -> { 1 } } }),
                                        passed to: { this -> { Cast$Supertype$Subtype$Sub2.<init>() -> { line 97 -> { 2 } } } }process analysis end

{ proc_name= Cast$Supertype$Subtype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype$Subtype*)]
; is_defined= true
; loc= Cast.java:71
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype$Subtype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype$Subtype* [line 71];
      n$1=_fun_Cast$Supertype.<init>()(n$0:Cast$Supertype$Subtype*) [line 71];
      NULLIFY(&this); [line 71];
      EXIT_SCOPE(n$0,n$1,this); [line 71];
      
    #n5:
      APPLY_ABSTRACTION; [line 109];
      
    process analysis
#n2:
      
    
    Cast$Supertype$Subtype.<init>1 disjuncts:
                                 #0: (conditions: (empty)
                                      phi: term_eqs: Cast$Supertype$Subtype.<init>()([v2])=v4
                                      { roots={ &this=v1 };
                                        mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                        attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                v2 -> { DynamicType Cast$Supertype$Subtype, SourceFile [None],
                                                        MustBeValid(, None, t=0),
                                                        UnknownEffect(function `Cast$Supertype$Subtype.<init>()` with no summary,
                                                                    in call to function `Cast$Supertype$Subtype.<init>()` with no summary at line 71 :t2
                                                                    [
                                                                    ] ) } };}
                                      PRE=[{ roots={ &this=v1 };
                                             mem  ={ v1 -> { * -> v2 },
                                                     v2 -> { * -> v3 },
                                                     v3 -> { } };
                                             attrs={ v1 -> { MustBeInitialized(, t=0),
                                                             MustBeValid(, None, t=0) },
                                                     v2 -> { MustBeInitialized(, t=0),
                                                             MustBeValid(, None, t=0) } };}]
                                      need_closure_specialization=false
                                      need_dynamic_type_specialization=
                                      { }
                                      skipped_calls={ Cast$Supertype$Subtype.<init>() -> call to skipped function occurs here }
                                      Topl={len=0;content=
                                             [  ]},
                                     conditions= [] timestamp= 7)
                                 
                                 Non-disj state:
                                   copy map: { }, parameter map: { }, 
                                   destructor checked: { }, captured: { }, 
                                   locked: false,
                                   loads: ({ n$0 -> { this } },{ this -> { line 71 -> { 1 } } }),
                                   passed to: { this -> { Cast$Supertype$Subtype.<init>() -> { line 71 -> { 2 } } } }process analysis end

{ proc_name= Cast$Supertype.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype*)]
; is_defined= true
; loc= Cast.java:4
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype* [line 4];
      n$1=_fun_Object.<init>()(n$0:Cast$Supertype*) [line 4];
      NULLIFY(&this); [line 4];
      EXIT_SCOPE(n$0,n$1,this); [line 4];
      
    #n5:
      APPLY_ABSTRACTION; [line 4];
      
    process analysis
#n2:
      
    
    Cast$Supertype.<init>1 disjuncts:
                         #0: (conditions: (empty) phi: term_eqs: Cast$Supertype.<init>()([v2])=v4
                              { roots={ &this=v1 };
                                mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                attrs={ v1 -> { MustBeValid(, None, t=0) },
                                        v2 -> { DynamicType Cast$Supertype, SourceFile [None],
                                                MustBeValid(, None, t=0),
                                                UnknownEffect(function `Cast$Supertype.<init>()` with no summary,
                                                              in call to function `Cast$Supertype.<init>()` with no summary at line 4 :t2
                                                              [] ) } };}
                              PRE=[{ roots={ &this=v1 };
                                     mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                                     attrs={ v1 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) },
                                             v2 -> { MustBeInitialized(, t=0),
                                                     MustBeValid(, None, t=0) } };}]
                              need_closure_specialization=false
                              need_dynamic_type_specialization={ }
                              skipped_calls={ Cast$Supertype.<init>() -> call to skipped function occurs here }
                              Topl={len=0;content=
                                     [  ]},
                             conditions= [] timestamp= 7)
                         
                         Non-disj state:
                           copy map: { }, parameter map: { }, destructor checked: { },
                           captured: { }, locked: false,
                           loads: ({ n$0 -> { this } },{ this -> { line 4 -> { 1 } } }),
                           passed to: { this -> { Cast$Supertype.<init>() -> { line 4 -> { 2 } } } }process analysis end

{ proc_name= Cast$Supertype$Subtype$Sub3.<init>()
; translation_unit= Cast.java
; formals= [(this,Cast$Supertype$Subtype$Sub3*)]
; is_defined= true
; loc= Cast.java:108
; locals= []
; ret_type= void 
; proc_id= Cast$Supertype$Subtype$Sub3.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype$Subtype$Sub3* [line 108];
      n$1=_fun_Cast$Supertype$Subtype.<init>()(n$0:Cast$Supertype$Subtype$Sub3*) [line 108];
      NULLIFY(&this); [line 108];
      EXIT_SCOPE(n$0,n$1,this); [line 108];
      
    #n5:
      APPLY_ABSTRACTION; [line 108];
      
    process analysis
#n2:
      
    
    Cast$Supertype$Subtype$Sub3.<init>1 disjuncts:
                                      #0: (conditions: (empty)
                                           phi: term_eqs: Cast$Supertype$Subtype$Sub3.<init>()([v2])=v4
                                           { roots={ &this=v1 };
                                             mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                                             attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                     v2 -> { DynamicType Cast$Supertype$Subtype$Sub3, SourceFile [None],
                                                             MustBeValid(, None, t=0),
                                                             UnknownEffect(function `Cast$Supertype$Subtype$Sub3.<init>()` with no summary,
                                                                    in call to function `Cast$Supertype$Subtype$Sub3.<init>()` with no summary at line 108 :t2
                                                                    [
                                                                    ] ) } };}
                                           PRE=[{ roots={ &this=v1 };
                                                  mem  ={ v1 -> { * -> v2 },
                                                          v2 -> { * -> v3 },
                                                          v3 -> { } };
                                                  attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                  MustBeValid(, None, t=0) },
                                                          v2 -> { MustBeInitialized(, t=0),
                                                                  MustBeValid(, None, t=0) } };}]
                                           need_closure_specialization=false
                                           need_dynamic_type_specialization=
                                           { }
                                           skipped_calls={ Cast$Supertype$Subtype$Sub3.<init>() -> call to skipped function occurs here }
                                           Topl={len=0;content=
                                                  [  ]},
                                          conditions= [] timestamp= 7)
                                      
                                      Non-disj state:
                                        copy map: { }, parameter map: { }, 
                                        destructor checked: { }, captured: { }, 
                                        locked: false,
                                        loads: ({ n$0 -> { this } },
                                        { this -> { line 108 -> { 1 } } }),
                                        passed to: { this -> { Cast$Supertype$Subtype$Sub3.<init>() -> { line 108 -> { 2 } } } }process analysis end

{ proc_name= Cast.<init>()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast*)]
; is_defined= true
; loc= Cast.java:3
; locals= []
; ret_type= void 
; proc_id= Cast.<init>() }
    #n1:
      
    #n4:
      n$0=*&this:Cast* [line 3];
      n$1=_fun_Object.<init>()(n$0:Cast*) [line 3];
      NULLIFY(&this); [line 3];
      EXIT_SCOPE(n$0,n$1,this); [line 3];
      
    #n5:
      APPLY_ABSTRACTION; [line 3];
      
    process analysis
#n2:
      
    
    Cast.<init>1 disjuncts:
               #0: (conditions: (empty) phi: term_eqs: Cast.<init>()([v2])=v4
                    { roots={ &this=v1 };
                      mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 } };
                      attrs={ v1 -> { MustBeValid(, None, t=0) },
                              v2 -> { DynamicType Cast, SourceFile [None],
                                      MustBeValid(, None, t=0),
                                      UnknownEffect(function `Cast.<init>()` with no summary,
                                                    in call to function `Cast.<init>()` with no summary at line 3 :t2
                                                    [] ) } };}
                    PRE=[{ roots={ &this=v1 };
                           mem  ={ v1 -> { * -> v2 }, v2 -> { * -> v3 }, v3 -> { } };
                           attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                                   v2 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
                    need_closure_specialization=false
                    need_dynamic_type_specialization={ }
                    skipped_calls={ Cast.<init>() -> call to skipped function occurs here }
                    Topl={len=0;content=
                           [  ]},
                   conditions= [] timestamp= 7)
               
               Non-disj state:
                 copy map: { }, parameter map: { }, destructor checked: { }, 
                 captured: { }, locked: false,
                 loads: ({ n$0 -> { this } },{ this -> { line 3 -> { 1 } } }),
                 process analysis end
passed to: { this -> { Cast.<init>() -> { line 3 -> { 2 } } } }
{ proc_name= Object Cast$Supertype$Subtype$Sub2.test2()
; translation_unit= Cast.java
; access= Public
; formals= [(this,Cast$Supertype$Subtype$Sub2*)]
; is_defined= true
; loc= Cast.java:102
; locals= [{ name= a; typ= java.lang.Object*; modify_in_block= false; is_declared_unused= false }]
; ret_type= java.lang.Object* 
; proc_id= Cast$Supertype$Subtype$Sub2.test2():java.lang.Object }
    #n1:
      
    #n4:
      n$0=*&this:Cast$Supertype$Subtype$Sub2* [line 103];
      _=*n$0:Cast$Supertype$Subtype$Sub2 [line 103];
      n$2=_fun_Cast$Supertype Cast$Supertype$Subtype$Sub2.test(Cast$Supertype)(n$0:Cast$Supertype$Subtype$Sub2*,null:java.lang.Object*) virtual [line 103];
      *&a:Cast$Supertype*=n$2 [line 103];
      NULLIFY(&this); [line 103];
      EXIT_SCOPE(_,n$0,n$2,this); [line 103];
      
    #n5:
      n$3=*&a:Cast$Supertype* [line 104];
      *&return:java.lang.Object*=n$3 [line 104];
      NULLIFY(&a); [line 104];
      EXIT_SCOPE(n$3,a); [line 104];
      APPLY_ABSTRACTION; [line 104];
      
    #n2:
      
    
    { proc_name= Cast$Supertype Cast$Supertype$Subtype$Sub2.test(Cast$Supertype)
    ; translation_unit= Cast.java
    ; access= Public
    ; formals= [(this,Cast$Supertype$Subtype$Sub2*);  (a,Cast$Supertype*)]
    ; is_defined= true
    ; loc= Cast.java:98
    ; locals= []
    ; ret_type= Cast$Supertype* 
    ; proc_id= Cast$Supertype$Subtype$Sub2.test(Cast$Supertype):Cast$Supertype }
    #n1:
      
    #n4:
      n$0=*&a:Cast$Supertype* [line 99];
      PRUNE(!(n$0 != null), true); [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$0,a); [line 99];
      
    #n6:
      *&return:Cast$Supertype*=null [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    #n5:
      n$0=*&a:Cast$Supertype* [line 99];
      PRUNE((n$0 != null), false); [line 99];
      EXIT_SCOPE(n$0); [line 99];
      
    #n7:
      n$1=*&a:Cast$Supertype* [line 99];
      *&return:Cast$Supertype*=n$1 [line 99];
      NULLIFY(&a); [line 99];
      EXIT_SCOPE(n$1,a); [line 99];
      APPLY_ABSTRACTION; [line 99];
      
    process analysis
#n2:
      
    
    Cast$Supertype$Subtype$Sub2.test2 disjuncts:
                                    #0: (conditions: {[v4] = 0}
                                         phi: var_eqs: v4=v6
                                              && linear_eqs: v4 = 0
                                              && term_eqs: 0=v4
                                              && intervals: v4=null ∧ v6=null
                                         { roots={ &a=v2, &this=v1, &return=v7 };
                                           mem  ={ v1 -> { * -> v3 },
                                                   v2 -> { * -> v4 },
                                                   v3 -> { * -> v5 },
                                                   v7 -> { * -> v6 } };
                                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                   v2 -> { MustBeValid(, None, t=0) },
                                                   v3 -> { DynamicType Cast$Supertype$Subtype$Sub2, SourceFile [None],
                                                           MustBeValid(, None, t=0) },
                                                   v4 -> { Invalid ConstantDereference(is assigned to the null pointer),
                                                           StaticType class Cast$Supertype },
                                                   v7 -> { MustBeValid(, None, t=5),
                                                           WrittenTo (5, ) } };}
                                         PRE=[{ roots={ &a=v2, &this=v1 };
                                                mem  ={ v1 -> { * -> v3 },
                                                        v2 -> { * -> v4 },
                                                        v3 -> { * -> v5 },
                                                        v4 -> { },
                                                        v5 -> { } };
                                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                MustBeValid(, None, t=0) },
                                                        v2 -> { MustBeInitialized(, t=0),
                                                                MustBeValid(, None, t=0) },
                                                        v3 -> { MustBeInitialized(, t=0),
                                                                MustBeValid(, None, t=0) },
                                                        v4 -> { UsedAsBranchCond(Cast$Supertype Cast$Supertype$Subtype$Sub2.test(Cast$Supertype), line 99, ) } };}]
                                         need_closure_specialization=false
                                         need_dynamic_type_specialization=
                                         { }
                                         skipped_calls={ }
                                         Topl={len=0;content=
                                                [  ]},
                                        conditions= [] timestamp= 8)
                                    #1: (conditions: {[v4] ≠ 0}
                                         phi: intervals: v4≠null && atoms: {[v4] ≠ 0}
                                         { roots={ &a=v2, &this=v1, &return=v8 };
                                           mem  ={ v1 -> { * -> v3 },
                                                   v2 -> { * -> v4 },
                                                   v3 -> { * -> v5 },
                                                   v8 -> { * -> v4 } };
                                           attrs={ v1 -> { MustBeValid(, None, t=0) },
                                                   v2 -> { MustBeValid(, None, t=0) },
                                                   v3 -> { DynamicType Cast$Supertype$Subtype$Sub2, SourceFile [None],
                                                           MustBeValid(, None, t=0) },
                                                   v4 -> { StaticType class Cast$Supertype },
                                                   v8 -> { MustBeValid(, None, t=5),
                                                           WrittenTo (5, ) } };}
                                         PRE=[{ roots={ &a=v2, &this=v1 };
                                                mem  ={ v1 -> { * -> v3 },
                                                        v2 -> { * -> v4 },
                                                        v3 -> { * -> v5 },
                                                        v4 -> { },
                                                        v5 -> { } };
                                                attrs={ v1 -> { MustBeInitialized(, t=0),
                                                                MustBeValid(, None, t=0) },
                                                        v2 -> { MustBeInitialized(, t=0),
                                                                MustBeValid(, None, t=0) },
                                                        v3 -> { MustBeInitialized(, t=0),
                                                                MustBeValid(, None, t=0) },
                                                        v4 -> { UsedAsBranchCond(Cast$Supertype Cast$Supertype$Subtype$Sub2.test(Cast$Supertype), line 99, ) } };}]
                                         need_closure_specialization=false
                                         need_dynamic_type_specialization=
                                         { }
                                         skipped_calls={ }
                                         Topl={len=0;content=
                                                [  ]},
                                        conditions= [] timestamp= 10)
                                    
                                    Non-disj state:
                                      copy map: { }, parameter map: { }, 
                                      destructor checked: { }, captured: { }, 
                                      locked: false,
                                      loads: ({ n$0 -> { a }, n$1 -> { a } },
                                      { a -> { line 99 -> { 1, 4 } } }),process analysis end
process analysis
 
                                      passed to: { }Cast$Supertype$Subtype$Sub2.test2
1 disjuncts:
#0: (conditions: (empty) phi: linear_eqs: v5 = 0 && term_eqs: 0=v5 && intervals: v5=null
     { roots={ &this=v1, &return=v6 };
       mem  ={ v1 -> { * -> v3 }, v2 -> { * -> v5 }, v3 -> { * -> v4 }, v6 -> { * -> v5 } };
       attrs={ v1 -> { MustBeValid(, None, t=0) },
               v2 -> { s&a (variable `a` declared here at line 102 :t0 ) at line 104,
                       MustBeValid(, None, t=4),
                       WrittenTo (4, ) },
               v3 -> { DynamicType Cast$Supertype$Subtype$Sub2, SourceFile [None],
                       MustBeValid(, None, t=0) },
               v5 -> { Invalid ConstantDereference(is assigned to the null pointer),
                       StaticType class Cast$Supertype },
               v6 -> { MustBeValid(, None, t=8), WrittenTo (8, ) } };}
     PRE=[{ roots={ &this=v1 };
            mem  ={ v1 -> { * -> v3 }, v3 -> { * -> v4 }, v4 -> { } };
            attrs={ v1 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) },
                    v3 -> { MustBeInitialized(, t=0), MustBeValid(, None, t=0) } };}]
     need_closure_specialization=false
     need_dynamic_type_specialization={ }
     skipped_calls={ }
     Topl={len=0;content=
            [  ]},
    conditions= [] timestamp= 13)

Non-disj state:
  copy map: { }, parameter map: { }, destructor checked: { }, captured: { }, 
  locked: false,
  loads: ({ n$0 -> { this }, n$3 -> { a } },
  { a -> { line 104 -> { 7 } }, this -> { line 103 -> { 1 } } }),
  passed to: { this -> { Cast$Supertype Cast$Supertype$Subtype$Sub2.test(Cast$Supertype) -> { line 103 -> { 3 } } } }process analysis end

  No issues found  
